---
title: "Session 3: Principles of Database Management"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
    Check your understanding of the tidyverse functions for managing relational data, 
    learn how to wrangle in steps and check each step,
    and start continue working on your Data Project.
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
library(knitr)

tutorial_options(exercise.timelimit = 60, exercise.checker = gradethis::grade_learnr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Ensure that library is loaded.
library(tidyverse)
```

```{r, context="data", include=FALSE}
# Ensure that the data is loaded for the remainder of this tutorial.
GlasgowFriends <- UsingRTutorials::GlasgowFriends
```

<!-- Define programming tip style -->
<style>
.tip {
  background-color: #f5f5f5;
}
</style>

<!-- Define question style -->
<style>
.question {
  color: #5A9DDB;
}
</style>

## Variables and Cases

R originated from a language for statistical analysis (the S language), so it should not come as a surrise that data are conceptualized primarily as variables in R. More precisely, a variable is called an _atomic vector_: a sequence of values of the same type (logical, integer, double, character, complex, raw).

###

R does not require that variables are joined in a data matrix. 

<div class="question" >
Use the `runif()` function to create a vector `var1` of 100 random numbers between 12 and 18. Use the same function to create a second vector (`var2`) of 100 random numbers between 1 and 10. Finally, calculate the Spearman correlation between the two vectors with the `stats::cor()` function. Is the rank correlation between two random variables zero?
</div>

```{r atomic_answer_hidden, eval=FALSE}
var1 <- runif(n = 100, min = 12, max = 18)
var2 <- runif(n = 100, min = 1, max = 10)
cor(var1, var2, method = "spearman")
```

```{r atomic, exercise = TRUE}

```

<!-- To hide the solution, use a textual hint. -->
<div id="atomic-hint">
__Hint:__ No piping now; we cannot pipe atomic vectors, we can only pipe data frames. The `stats::` package, like the `base::` package, is automatically loaded when R starts.
</div>

```{r atomic-check}
gradethis::grade_result(
  pass_if(~ !identical(.result, 0), "With random variables, the result will vary but most of the times there is a weak positive or negative rank correlation. By the way, I cannot check if you used the Spearman method."),
  fail_if(~ identical(.result, 0), "In the first line, create the first vector, in the second line the second vector, and in the third line calculate the correlation.")
)
```

###

The two vectors `var1` and `var2` that you have just created are of equal length. Function `cor()` produces an error if you attempt to calculate a correlation between two vectors of unequal length. You may check this by changing the above code. This is because R links the first element (number) of vector `var1` to the first element (number) of vector `var2`. It assumes that these two numbers refer to the same case. For example, `var1` may express a student's age and `var2` may express their grade for an IQ test.

<div class="question" >
What happens to the rank correlation between `var1` and `var2` if you first sort each vector? Copy the code from the previous code box as your starting point.
</div>

Note: We cannot use the tidyverse function `arrange()` because tidyverse functions work on data frames, not on individual atomic vectors. For once, use the `base::sort()` function.

```{r atomicsorted_answer_hidden, eval=FALSE}
var1 <- sort(runif(n = 100, min = 12, max = 18))
var2 <- sort(runif(n = 100, min = 1, max = 10))
cor(var1, var2, method = "spearman")
```

```{r atomicsorted, exercise = TRUE}

```

```{r atomicsorted-check}
gradethis::grade_code(
  correct = "", 
  incorrect = ""
  )
gradethis::grade_result(
  pass_if(~ .result > 0.999, "Because both variables are sorted from small to large, there is (nearly) perfect rank correlation. Cases with lower scores on one variable are matched to case with lower scores on the other variable."),
  fail_if(~ .result <= 0.999, "Create data objects for the two sorted vectors before you calculate the correlation. Did you use Spearman's correlation?")
)
```

###

Working with individual atomic vectors, then, is hazardous. If the order of cases differs between vectors, the wrong values are linked, and the results are incorrect.

For this reason, atomic vectors of the same length are usually combined into data frames or in tibbles, which are data frames with easy printing (few cases to screen) and no sneaky changes. Note that vectors are the columns in a data frame or tibble. R is column oriented!

Tidyverse functions produce tibbles, base R functions produce data frames. If you have to use functions outside of the tidyverse suite, you may have to change your tibble back into a data frame.

<div class="question" >
Check that you understand tibbles: Create the tibble depicted below with one command (no piping). Mind the details!
</div>

```{r tibbleShown}
tibble(
  var1 = c("a", "b", NA, "d"),
  `standard normal random number` = rnorm(4, mean = 0, sd = 1),
  numbers12_15 = seq(from = 12, to = 15, by = 1),
  success = c( FALSE, FALSE, TRUE, FALSE)
)
```

```{r tibble, exercise = TRUE}

```

<!-- To hide the solution, use a textual hint. -->
<div id="tibble-hint">
__Hint:__ Use `c()` for creating a vector from a set of values unless you can create the vector with a function. A standard normal distribution has mean 0 and standard deviation 1.
</div>

```{r tibble-solution}
tibble( var1 = c("a", "b", NA, "d"), `standard normal random number` = rnorm(4, mean = 0, sd = 1), numbers12_15 = seq(from = 12, to = 15, by = 1), success = c( FALSE, FALSE, TRUE, FALSE) )
```

```{r tibble-check}
gradethis::grade_code(
  correct = "", 
  incorrect = "(If you used `12:15` instead of `seq()` to create the third variable, that is OK.)"
  )
```

## Tidy Data: EveRything In One Place

Rules for optimal data structure (efficiency and consistency):  

1. Each type of case must have its own table.  
    + Is the same information repeated in different rows?  
    + Split the table; transfer the info on each type of case to a separate table.  
    + The book _R for Data Science_ does not discuss this much.

2. Each observation must have its own row.  
    + Do different variables address the same information?  
    + Stack repeated information.  
    + Don't allow values as columns.

3. Each variable must have its own column.  
    + Is there a variable with values that should be variables by themselves? 
    + Don't stack different types of information in the same column.
    + Spread information over different columns.

4. Each value must have its own cell.  
    + Does a variable contain more than one piece of information?
    + Don't cram more than one piece of information in a cell.  
    + Split the variable.

### 1. Each type of case must have its own table

The data set for this tutorial, `GlasgowFriends` is very untidy. Let us tidy it up in steps to check that you understand the concept of tidy data and are able to tidy your Data Project data.

Data arising from practical sources or research designs other than the most simple ones usually contain information about different types of cases. For example, a data set may contain information that belongs to a person, to an organization, to a particular moment in time. In addition, there can be information that describes a combination of case types, for example, information on a person at a particular moment in time.

For understanding and tidying your data, it is paramount to identify the types of cases in your data.

<div class="question" >
Use help on `GlasgowFriends` to guess different types of cases in this data set. For each variable, ask yourself the question: What thing has this characteristic?
</div>

```{r GlasgowFriends, exercise = TRUE}
?GlasgowFriends
```

### Primary key

You have probably identified _student_ as one type of cases in `GlasgowFriends`. _Neighbourhood_ seems to be a different type of cases, with characteristics (variables) that are different from the characteristics of a student. And then there is this variable `wave`, which is a characteristic of neither a student nor a neighbourhood.

For identifying types of cases, it is helpful to find the smallest set of variables for which every case (row in the data matrix) has a unique combination of values. This smallest set of variables is called the _primary key_.

Imagine that a data matrix contains only information about a person, such as the person's name, year of birth, address, social security number, and best friend's name. We only need the social security number to uniquely identify a person. If we know this number, we can look up a person's name, year of birth, and so on. 

If we would have two cases with the same social security number, we suspect that there is an error in the data or that there is no unique row for a person. The latter situation arises if there are more types of cases in the data than just persons. An additional variable that we must add to the social security number for getting a primary key points us in the direction of other types of cases.

<div class="tip" >
__Tip__

Identifying the primary key of a data frame or tibble:

1. From the data description, select variables that you think identify types of cases.
2. Select these variables with `select()`.
3. Use the function `anyDuplicated()` to check if there is a case (row) with the same values on the selected variables as a preceding case.
    + If there is a duplicate, add a variable to the key (go to Step 1).
    + If there are no duplicates, see if you can remove a variable and still have no duplicates (and go to Step 2).
</div>

<div class="question" >
Write code that identifies the primary key of tibble `GlasgowFriends`. You may have to try out different combinations of variables; submit only the final code for checking. </div>

```{r primarykeyhidden, eval=FALSE}
# primary key: this seems to be the only option with four variables
GlasgowFriends %>%
  select(student, wave, bestfriend, bfperiod) %>%
  anyDuplicated()
```

```{r primarykey, exercise = TRUE}

```

```{r primarykey-solution}
GlasgowFriends %>% select(student, wave, bestfriend, bfperiod) %>% anyDuplicated()
```

```{r primarykey-check}
gradethis::grade_code(
  correct = "", 
  incorrect = " Well, maybe you just entered the variables in another order than I expected. If the result is 0 and you use just four variables, your have the correct primary key."
  )
```

Don't worry if you cannot find the primary key. Press the _Continue_ button for a strategy that you can use to find the primary key.

### Finding the primary key

If you have checked help on function `anyDuplicated()`, you have seen that this function reports the number of the first case (row) that duplicates a preceding row. It doesn't report which preceding row is duplicated, however.

If it is difficult to find the primary key, use the data wrangling techniques that you learned in Session 2 to select cases (rows) with a combination of values on the selected variables that is not unique. Compare rows that are not unique: Which variable has different values? This is the variable that you should add to the primary key.

<div class="question" >
1. Use the code below to find out which variable must be added because it has different values for the first pair of cases that have the same `student` and `wave` values.
2. Add this variable to the code below. Any variable that must still be added to obtain a primary key?
</div>

```{r primarykey2, exercise = TRUE}
# Display cases with the same provisional primary key as consecutive cases.
GlasgowFriends %>%
  # for each combination of selected primary key variables...
  group_by( student, wave ) %>%
  # ...calculate and add the number of cases with the same values
  mutate(n_identical = n()) %>%
  # retain only cases that are not unique on the selected variables
  filter(n_identical > 1) %>%
  # sort the cases, so duplicates are next to each other
  arrange( student, wave ) %>% 
  # show only the first two cases that are duplicates
  ungroup() %>%
  slice(1:2)
```

### Finding the type of cases for a variable 

Every variable in your primary key and every combination of these variables may represent a different type of cases. 

In case the primary key consists of the variables `student` and `wave`, the types of cases can be:

- Student/person,
- Wave/time point or period,
- Student per wave or, equivalently, wave per student.

For practical purposes, it suffices to identify types of cases for which there are at least two variables in the tibble. In tibble `GlasgowFriends` we have the following variables for each type of cases:

- Student or person: `student`, `neighbourhood`, `age`, `sex`, and several more, which represent student characteristics that do not change between waves.
- Wave or time point/period: only `wave`.
- Student per wave or, equivalently, wave per student: `alcohol`, `cannabis`, `tobacco`, and several more, which represent student characteristics that may change between waves.

If we have only one variable describing the data collection wave, we do not have to consider this as a separate type of cases. In contrast, student and student per wave are relevant types of cases here.

Student characteristics that do not change between waves must have the same values for a student across all waves. So characteristics (variables) that always have the same value for a student belong to the student type of cases. These variabls should eventually be split off into a tibble with one case (row) per student.

In contrast, student characteristics that change between waves belong to the student-per-wave type of cases and should have their own tibble. 

<div class="tip" >
__Tip__

Finding the type of cases for a variable:

1. Use common sense: The variable is a characteristic of what?
2. Check that the variable has the same value for each value of the variables that identify a type of cases (use the code below). If so, the variable is a characteristic of this type of cases or of a simpler type of cases, see Step 3.
3. If Step 2 is true and the type of cases is identified by more than one variable, for example, student per wave, repeat Step 2 for each subset of the identifying variables.
4. The variable belongs to the simplest type of cases (identified by fewest variables) satisfying the check in Step 2.
</div>

<div class="question" >
For each variable in `GlasgowFriends` determine to which type of case it belongs.
</div>

```{r casetype, exercise = TRUE}
# Code to check that a variable .var. always has the same value for each value of the selected type of case .type. .
# Replace .var. by a variable name and replace .type. by the variable(s) that define the type of case.
GlasgowFriends %>%
  # For each value of the selected type of case...
  group_by( .type. ) %>%
  # ... calculate the number of distinct values of the selected variable.
  summarise(n_distinct = n_distinct( .var. ), .groups = "drop") %>%
  # Count number of distinct variable values per type of case (grouping has been dropped): should always be 1.
  count(n_distinct)
```

```{r casetype-hint-1}
# Example: Checking that variable age is unique for each student-wave combination.
GlasgowFriends %>%
  # For each value of the selected type of case...
  group_by( student, wave ) %>%
  # ... calculate the number of distinct values of the selected variable.
  summarise(n_distinct = n_distinct( age ), .groups = "drop") %>%
  # Count number of distinct variable values per type of case (grouping has been dropped): should always be 1.
  count(n_distinct)
# In the output of this code, 'n_distinct' gives the number of different ages encountered per student per wave. Column 'n' gives the number (frequency) of student per wave combinations.
```

```{r casetype-hint-2}
# If 'age' is unique for each student-wave combination, it can also be unique for each student. If so, 'age' belongs to the student type of case, not the student per wave typ of case.
# Example: Checking that variable age is unique for each student-wave combination.
GlasgowFriends %>%
  # For each value of the selected type of case...
  group_by( student ) %>%
  # ... calculate the number of distinct values of the selected variable.
  summarise(n_distinct = n_distinct( age ), .groups = "drop") %>%
  # Count number of distinct variable values per type of case (grouping has been dropped): should always be 1.
  count(n_distinct)
# In the output of this code, 'n_distinct' gives the number of different ages encountered per student. Column 'n' gives the number (frequency) of students.
```

<div class="tip" >
__Programming Tip__

- Be systematic and precise!
- For example, if a primary key is defined as _the smallest set of variables for which every case has a unique combination of values_, check both parts of the definition: 
    (1) Every case has a unique combination of values,
    (2) and this is the smallest set of variables for which 1 holds.
</div>

### Splitting a table

Now that we have identified the types of cases in the data set and assigned the variables to types of cases, we can start tidying the data set. We are going to create a separate tibble for each type of case and we remove duplicates from each new table. We get rid of repeated information!

Why do we do that? Because this way, each piece of information is stored only once:

- No notational variations, e.g., a person's social security number cannot be different in different cases.
- Easy editing/updating: change/add a value only in one place.
- Max storage efficiency: no repetition of information.
- Information is stored by type of cases: easier to find.
- Any multilevel structure of the data (for statistical analysis) is clear from the presence of different tables.

<div class="question" >
Use your data wrangling skills from Session 2 and the [data transformation cheatsheet](https://www.rstudio.org/links/data_transformation_cheat_sheet) to create a tibble for each type of case in `GlasgowFriends` and name these tibbles `Student`, `StudentWave`, and `StudentBestfriend`.
</div>

```{r studenttable, exercise = TRUE, exercise.lines = 5}
# Your code to create a table for student information without duplicates.

# Use View(Student) if you want to view the contents of the table that you created.
# But note that the code checker won't work if you add this command.

```

<!-- To hide the solution, use a textual hint. -->
<div id="studenttable-hint">
__Hint:__ Use the cheatsheet to find a function to retain only distinct cases/rows. For now, include the neighbourhood variables in the Student tibble.
</div>

```{r studenttable-solution}
Student <- GlasgowFriends %>% select(student, neighbourhood, schooldist, hoodname, age, sex, smoking_at_home, smoking_parents, smoking_siblings) %>% distinct()
```

```{r studenttable-check}
gradethis::grade_code(
  correct = "", 
  incorrect = " However, if you selected 9 variables and the new tibble contains 160 rows, your code is fine. You probably selected the variables in a different order."
  )
```


```{r studentwavetable, exercise = TRUE, exercise.lines = 5}
# Your code to create a table for student per wave information without duplicates.

# Use View(StudentWave) if you want to view the contents of the table that you created.
# But note that the code checker won't work if you add this command.

```

<!-- To hide the solution, use a textual hint. -->
<div id="studentwavetable-hint">
__Hint:__ It is a good custom to use the primary key variables as the first variables in a tibble.
</div>

```{r studentwavetable-solution}
StudentWave <- GlasgowFriends %>% select(student, wave, alcohol, cannabis, money, romantic, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) %>% distinct()
```

```{r studentwavetable-check}
gradethis::grade_code(
  correct = "", 
  incorrect = " However, if you selected 12 variables and the new tibble contains 480 rows, your code is fine. You probably selected the variables in a different order."
  )
```

<div class="question" >
Include the `student` variable in the `StudentBestfriend` tibble.
</div>

```{r bestfriendstable, exercise = TRUE, exercise.lines = 5}
# Your code to create a table for best friends information without duplicates.

# Use View(StudentBestfriend) if you want to view the contents of the table that you created.
# But note that the code checker won't work if you add this command.

```

<!-- To hide the solution, use a textual hint. -->
<div id="bestfriendstable-hint">
__Hint:__ Include the `student` variable, otherwise we don't know who nominated the best friend.
</div>

```{r bestfriendstable-solution}
StudentBestfriend <- GlasgowFriends %>% select(student, bestfriend, bfperiod, bfwave ) %>% distinct()
```

```{r bestfriendstable-check}
gradethis::grade_code(
  correct = "", 
  incorrect = " However, if you selected 4 variables and the new tibble contains 519 rows, your code is fine. You probably selected the variables in a different order."
  )
```

### 

Not all repeated information can be found with the help of the primary key. If you look carefully at the student tibble that you split off from tibble `GlasgowFriends`, you may notice that neighbourhood information is repeated. This suggests that neighbourhood is a type of cases that should be split off into a separate table.

```{r showStudentTable}
GlasgowFriends %>% select(student, neighbourhood, schooldist, hoodname, age, sex, smoking_at_home, smoking_parents, smoking_siblings) %>% distinct() %>% arrange(neighbourhood, student)
```

<div class="question" >
Split off the neigbourhood information into a tibble called `Neighbourhood`. Use one pipe.
</div>

```{r hoodtable, exercise = TRUE, exercise.lines = 5, exercise.setup = "studenttable-solution" }
# Your code to create a table for neighbourhood information without duplicates.

# Use View(Neighbourhood) if you want to view the contents of the table that you created.
# But note that the code checker won't work if you add this command.

```

<!-- To hide the solution, use a textual hint. -->
<div id="hoodtable-hint">
__Hint:__ Use the `Student` tibble as your starting point..
</div>

```{r hoodtable-solution, exercise.setup = "studenttable-solution"}
Neighbourhood <- Student %>% select(neighbourhood, schooldist, hoodname) %>% distinct()
```

```{r hoodtable-check}
gradethis::grade_code(
  correct = "", 
  incorrect = " However, if you selected 3 variables and the new tibble contains 4 rows, your code is fine. You probably selected the variables in a different order."
  )
```

###

<div class="question" >
Find the primary key of the `Neighbourhood` tibble.
</div>

```{r hoodtablekey, exercise = TRUE, exercise.setup = "hoodtable-solution"}
# Your code to identify the primary key of the neighbourhood tibble.

```

<!-- To hide the solution, use a textual hint. -->
<div id="hoodtablekey-hint">
__Hint:__ Use code presented earlier in this tutorial as your starting point.
</div>

```{r hoodtablekey-solution}
Neighbourhood %>% select(neighbourhood) %>% anyDuplicated()
```

```{r hoodtablekey-check}
gradethis::grade_code(
  correct = "", 
  incorrect = "Review the subsections 'Primary key' and `Finding the primary key` in this tutorial."
  )
```

###

<div class="question" >
Remove the neighbourhood information from the `Student` tibble except the variable(s) that constitute(s) the primary key of the `Neighbourhood` tibble.
</div>

```{r student2table, exercise = TRUE, exercise.lines = 5, exercise.setup = "studenttable-solution"}
# Your code to remove the superfluous neighbourhood variables from the Student tibble.

# Use View(Student) if you want to view the contents of the resulting table.
# But note that the code checker won't work if you add this command.

```

<!-- To hide the solution, use a textual hint. -->
<div id="student2table-hint">
__Hint:__ It is more efficient to specify the variables that must be dropped (use the `-` sign) than the ones that must be retained.
</div>

```{r student2table-solution}
Student <- Student %>% select(-schooldist, -hoodname)
```

```{r student2table-check}
gradethis::grade_code(
  correct = "", 
  incorrect = " However, if you the new STudent tibble contains 7 variables and (still) 160 rows, your code is probably fine. You may have selected the variables in a different way."
  )
```

### Foreign key, one-to-many vs. many-to-many relations

The primary key of the `Neighbourhood` tibble must remain in the `Student` tibble, otherwise we no longer know a student's neighbourhood if we stop using the `GlasgowFriends` tibble. Do we stop using the `GlasgowFriends` tibble? Sure, because it is untidy.

The primary key of the `Neighbourhood` tibble is called a _foreign key_ in the `Student` tibble. With primary keys and foreign keys, we can join information from different tables. Actually, we could reconstruct the `GlasgowFriends` tibble from the split-off tables.

In case you wonder why the primary key of the `GlasgowFriends` tibble gave us the student, student-per-wave, and best-friend types of cases but not the neighbourhood type of cases, here is an important distinction:

1. _One-to-many relation_: A student is living in only one neighbourhood (at least in this data set) even though many students can live in the same neighbourhood. As a consequence, a student has only one score on the `neighbourhood` variable, just like they have only one score on the `sex`variable (at least in this data set). So we cannot distinguish between a real student characteristic like sex and a different type of cases, such as neighbourhood by looking at variation in scores per student.
2. _Many-to-many relation_: A student may appear in many waves (actually, three in this data set) and a wave may include many students. If the data set contains a separate case for each wave for each student, we have variation in waves across students (and the other way around). The primary key picks this up.

However, not every many-to-many relation is picked up by the pimary key. This is the next topic of this tutorial.

But first: Enjoy that you have come so far. You have covered quite a lot of ground. The insights and skills you have gained may prove very valuable during your career.

### 2. Each observation must have its own row.

